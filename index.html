<!DOCTYPE html>
<html lang="sr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Blok Igrice</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI',Tahoma,sans-serif}
        body{background:linear-gradient(135deg,#0f2027 0%,#203a43 50%,#2c5364 100%);color:#fff;height:100vh;display:flex;align-items:center;justify-content:center}
        #mainMenu,#tetrisScreen,#blockScreen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:30px;transition:transform .5s}
        #mainMenu.hidden,#tetrisScreen.hidden,#blockScreen.hidden{transform:translateY(120%)}
        h1{font-size:2.5rem;text-shadow:0 0 10px rgba(255,255,255,.5)}
        button{background:#fff;color:#0f2027;border:none;padding:14px 40px;border-radius:30px;font-size:1.2rem;font-weight:700;box-shadow:0 0 15px rgba(0,0,0,.4);cursor:pointer;transition:.3s}
        button:hover{background:#0f2027;color:#fff}
        #settingsBtn{position:absolute;top:20px;right:20px;background:transparent;border:none;font-size:2rem;color:#fff}
        #settingsBtn:hover{transform:rotate(90deg)}
        #blockGrid{display:grid;grid-template-columns:repeat(10,30px);grid-template-rows:repeat(10,30px);gap:2px;background:#111;padding:6px;border-radius:8px}
        #blockGrid div{background:#222;border-radius:4px}
        #blockGrid .filled{background:#00bcd4}
        #blockPreview{display:flex;gap:20px;margin-bottom:20px}
        .previewBox{display:grid;grid-template-columns:repeat(4,20px);grid-template-rows:repeat(4,20px);gap:2px;background:#111;padding:4px;border-radius:6px}
        .previewBox div{background:#222;border-radius:3px}
        .previewBox .filled{background:#00bcd4}
        #tetrisCanvas{background:#111;border-radius:8px}
        #score,#level,#lines{font-size:1.2rem;margin:5px}
    </style>
</head>
<body>

    <!-- Glavni meni -->
    <div id="mainMenu">
        <h1>Izaberi igricu</h1>
        <button onclick="openTetris()">Tetris</button>
        <button onclick="openBlockPuzzle()">Blok puzle</button>
        <button id="settingsBtn" onclick="alert('Podešavanja nisu implementirana')">⚙️</button>
    </div>

    <!-- Tetris ekran -->
    <div id="tetrisScreen" class="hidden">
        <button onclick="backToMenu()">⬅ Nazad</button>
        <canvas id="tetrisCanvas" width="300" height="600"></canvas>
        <div>
            <div id="score">Rezultat: 0</div>
            <div id="level">Nivo: 1</div>
            <div id="lines">Linije: 0</div>
        </div>
    </div>

    <!-- Blok puzle ekran -->
    <div id="blockScreen" class="hidden">
        <button onclick="backToMenu()">⬅ Nazad</button>
        <div id="blockPreview"></div>
        <div id="blockGrid"></div>
    </div>

    <script>
        /* Pomoćne funkcije */
        function backToMenu(){
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('tetrisScreen').classList.add('hidden');
            document.getElementById('blockScreen').classList.add('hidden');
            if(window.tetrisLoop) clearInterval(window.tetrisLoop);
        }
        function openTetris(){
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('tetrisScreen').classList.remove('hidden');
            startTetris();
        }
        function openBlockPuzzle(){
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('blockScreen').classList.remove('hidden');
            initBlockPuzzle();
        }

        /* Tetris logika */
        const BOARD_W = 10, BOARD_H = 20;
        const SHAPES = [
            [[1,1,1,1]],
            [[1,1],[1,1]],
            [[1,1,1],[0,1,0]],
            [[1,1,1],[1,0,0]],
            [[1,1,1],[0,0,1]],
            [[0,1,1],[1,1,0]],
            [[1,1,0],[0,1,1]]
        ];
        let board, piece, score=0, level=1, lines=0;
        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');
        const SIZE = 30;
        function createBoard(){
            board = Array.from({length:BOARD_H},()=>Array(BOARD_W).fill(0));
        }
        function drawBoard(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle='#111';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            for(let y=0;y<BOARD_H;y++){
                for(let x=0;x<BOARD_W;x++){
                    if(board[y][x]){
                        ctx.fillStyle='#00bcd4';
                        ctx.fillRect(x*SIZE,y*SIZE,SIZE,SIZE);
                    }
                }
            }
            if(piece){
                ctx.fillStyle='#fff';
                piece.shape.forEach((row,dy)=>{
                    row.forEach((val,dx)=>{
                        if(val){
                            ctx.fillRect((piece.x+dx)*SIZE,(piece.y+dy)*SIZE,SIZE,SIZE);
                        }
                    });
                });
            }
        }
        function newPiece(){
            const idx = Math.floor(Math.random()*SHAPES.length);
            piece = {shape:SHAPES[idx],x:Math.floor(BOARD_W/2)-1,y:0};
            if(collision()){
                alert('Kraj igre!');
                backToMenu();
            }
        }
        function collision(){
            for(let y=0;y<piece.shape.length;y++){
                for(let x=0;x<piece.shape[y].length;x++){
                    if(piece.shape[y][x]){
                        let nx = piece.x+x;
                        let ny = piece.y+y;
                        if(nx<0||nx>=BOARD_W||ny>=BOARD_H||(ny>=0&&board[ny][nx])) return true;
                    }
                }
            }
            return false;
        }
        function rotate(){
            const rotated = piece.shape[0].map((_,i)=>piece.shape.map(row=>row[i]).reverse());
            const prev = piece.shape;
            piece.shape = rotated;
            if(collision()) piece.shape = prev;
        }
        function move(dir){
            piece.x += dir;
            if(collision()) piece.x -= dir;
        }
        function drop(){
            piece.y++;
            if(collision()){
                piece.y--;
                merge();
                clearLines();
                newPiece();
            }
        }
        function merge(){
            piece.shape.forEach((row,dy)=>{
                row.forEach((val,dx)=>{
                    if(val){
                        board[piece.y+dy][piece.x+dx]=1;
                    }
                });
            });
        }
        function clearLines(){
            let count=0;
            for(let y=BOARD_H-1;y>=0;y--){
                if(board[y].every(v=>v)){
                    board.splice(y,1);
                    board.unshift(Array(BOARD_W).fill(0));
                    count++;
                    y++;
                }
            }
            if(count){
                lines += count;
                score += count*100*level;
                level = Math.floor(lines/10)+1;
                document.getElementById('score').textContent='Rezultat: '+score;
                document.getElementById('level').textContent='Nivo: '+level;
                document.getElementById('lines').textContent='Linije: '+lines;
            }
        }
        function startTetris(){
            createBoard();
            score=level=lines=0;
            document.getElementById('score').textContent='Rezultat: 0';
            document.getElementById('level').textContent='Nivo: 1';
            document.getElementById('lines').textContent='Linije: 0';
            newPiece();
            drawBoard();
            if(window.tetrisLoop) clearInterval(window.tetrisLoop);
            window.tetrisLoop = setInterval(()=>{drop();drawBoard();},500/level);
            window.addEventListener('keydown',e=>{
                if(e.key==='ArrowLeft') move(-1);
                if(e.key==='ArrowRight') move(1);
                if(e.key==='ArrowDown') drop();
                if(e.key==='ArrowUp') rotate();
                drawBoard();
            });
        }

        /* Blok puzle logika */
        const BLOCK_SHAPES = [
            [[1,1],[1,1]],
            [[1,1,1],[1,0,0]],
            [[1,1,1,1]],
            [[1,1,0],[0,1,1]],
            [[0,1],[0,1],[1,1]]
        ];
        let blockBoard, selectedShape;
        function initBlockPuzzle(){
            blockBoard = Array(100).fill(0);
            renderBlockGrid();
            generateShapes();
        }
        function renderBlockGrid(){
            const grid = document.getElementById('blockGrid');
            grid.innerHTML='';
            blockBoard.forEach((cell,i)=>{
                const div = document.createElement('div');
                if(cell) div.classList.add('filled');
                div.dataset.index=i;
                grid.appendChild(div);
            });
        }
        function generateShapes(){
            const preview = document.getElementById('blockPreview');
            preview.innerHTML='';
            for(let i=0;i<3;i++){
                const idx = Math.floor(Math.random()*BLOCK_SHAPES.length);
                const shape = BLOCK_SHAPES[idx];
                const box = document.createElement('div');
                box.classList.add('previewBox');
                box.dataset.shape=idx;
                for(let r=0;r<4;r++){
                    for(let c=0;c<4;c++){
                        const cell=document.createElement('div');
                        if(shape[r]&&shape[r][c]) cell.classList.add('filled');
                        box.appendChild(cell);
                    }
                }
                box.addEventListener('click',()=>selectShape(idx));
                preview.appendChild(box);
            }
        }
        function selectShape(idx){
            selectedShape = BLOCK_SHAPES[idx];
            alert('Oblik izabran! Klikni na mrežu da postaviš.');
            document.getElementById('blockGrid').onclick = e=>{
                const i = parseInt(e.target.dataset.index);
                if(isNaN(i)) return;
                const x = i%10, y = Math.floor(i/10);
                if(canPlace(selectedShape,x,y)){
                    placeShape(selectedShape,x,y);
                    generateShapes();
                }
            };
        }
        function canPlace(shape,x,y){
            for(let r=0;r<shape.length;r++){
                for(let c=0;c<shape[r].length;c++){
                    if(shape[r][c]){
                        const nx=x+c, ny=y+r;
                        if(nx<0||nx>=10||ny<0||ny>=10||blockBoard[ny*10+nx]) return false;
                    }
                }
            }
            return true;
        }
        function placeShape(shape,x,y){
            for(let r=0;r<shape.length;r++){
                for(let c=0;c<shape[r].length;c++){
                    if(shape[r][c]){
                        blockBoard[(y+r)*10+(x+c)]=1;
                    }
                }
            }
            renderBlockGrid();
            checkFullRowsCols();
        }
        function checkFullRowsCols(){
            // proveri redove
            for(let r=0;r<10;r++){
                if(blockBoard.slice(r*10,r*10+10).every(v=>v)){
                    blockBoard.splice(r*10,10);
                    blockBoard.unshift(...Array(10).fill(0));
                }
            }
            // proveri kolone
            for(let c=0;c<10;c++){
                let full=true;
                for(let r=0;r<10;r++){
                    if(!blockBoard[r*10+c]){full=false;break;}
                }
                if(full){
                    for(let r=0;r<10;r++) blockBoard[r*10+c]=0;
                }
            }
            renderBlockGrid();
        }
    </script>
</body>
</html>
